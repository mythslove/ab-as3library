package net.guttershark.util.collections{	import net.guttershark.util.collections.ArrayBidirectionalIterator;	import net.guttershark.util.collections.ILoopableIterator;	import net.guttershark.util.collections.IPointerIterator;		/**	 * ArrayLoopableIterator provides a non-destructive, pointer-based, Looping Bi-Directional Array Iterator.	 */	public class ArrayLoopableIterator extends ArrayBidirectionalIterator implements ILoopableIterator, IPointerIterator 	{		/**		 * ArrayLoopableIterator Constructor		 */		public function ArrayLoopableIterator(array:Array) 		{			super(array);		}		/**		 * Override: ArrayLoopableIterator starts at end upon interating to the begining.		 */		override public function previous():Object 		{			if(super.hasPrevious()) 			{				return super.previous();			} else 			{				_pointer = _array.length - 1;				return _array[_pointer];			}		}		/**		 * Override: ArrayLoopableIterator starts at beginning once iteration completes.		 * @return Object		 */		override public function next():Object 		{			if(super.hasNext()) 			{				return super.next();			} else 			{				super.reset();				return super.next();			}		}				/**		 * Override: ArrayLoopableIterator always has a next element.		 */		override public function hasPrevious():Boolean 		{			return true;		}			/**		 * Override: ArrayLoopableIterator always has a previous element.		 */		override public function hasNext():Boolean 		{			return true;		}			/**		 * Return a <code>glimple</code> of the previous element without 		 * directionally iterating the pointer backwards.		 */		override public function glimpse():Object 		{			if(super.hasPrevious()) 			{				return super.glimpse();				} else 			{				return _array[_array.length - 1];			}		}		/**		 * Return a <code>peek</code> of the next element without 		 * directionally iterating the pointer forwards.		 */		override public function peek():Object 		{			if (super.hasNext()) 			{				return super.peek();			} else 			{				return _array[0];			}		}		/**		 * Return <code>true</code> if pointer is at the begining of the collection.		 */		public function isAtStart():Boolean 		{			return (_pointer == 0);		}		/**		 * Return <code>true</code> if pointer is at the end of the collection.		 */		public function isAtEnd():Boolean 		{			return (_pointer == _array.length - 1);		}	}}