package net.guttershark.display{	import flash.events.EventDispatcher;
	import flash.events.NetStatusEvent;
	import flash.events.TimerEvent;
	import flash.media.SoundTransform;
	import flash.media.Video;
	import flash.net.NetConnection;
	import flash.net.NetStream;
	import flash.utils.Timer;
	import flash.utils.setTimeout;
	
	import net.guttershark.managers.AssetManager;
	import net.guttershark.support.events.FLVEvent;
	import net.guttershark.util.MathUtils;		/**	 * Dispatched when the flv starts playing. The event	 * manager can handle this event, as "Start".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("start", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when the flv stops playing. The event	 * manager can handle this event, as "Stop".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("stop", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched for progress of the flv. The event	 * manager can handle this event, as "Progress".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("progress", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when meta data is received for the current flv. The event	 * manager can handle this event, as "Meta".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("metaData", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when the buffer is empty. The event	 * manager can handle this event, as "BufferEmpty".	 * When this is dispatched, you should pause the video,	 * and wait for the buffer full event.	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("bufferEmpty", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when the buffer is full. The event	 * manager can handle this event, as "BufferFull".	 * When this is dispatched, you can begin playing	 * the video again - call play or resume.	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("bufferFull", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when the buffer was flushed. The event	 * manager can handle this event, as "BufferFlush".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("bufferFlush", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when an invalid seek time was attempted. The event	 * manager can handle this event, as "SeekInvalidTime".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("seekInvalidTime", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when a seek occurs. The event	 * manager can handle this event, as "SeekNotify".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("seekNotify", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when a stream was not found. The event	 * manager can handle this event, as "StreamNotFound".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("streamNotFound", type="net.guttershark.support.events.FLVEvent")]		/**	 * Dispatched when a cue point is reached. The event	 * manager can handle this event, as "CuePoint".	 * 	 * @eventType net.guttershark.support.events.FLVEvent	 */	[Event("cuePoint", type="net.guttershark.support.events.FLVEvent")]	
	/**	 * The FLV class is the most basic way to play an FLV - all attempts	 * to play a video first checks the AssetManager for a net stream,	 * or a new net stream is created  and registered with the	 * asset manager for later use. At no point does the net connection	 * get "closed" - so that it stays in memory. If you need to close	 * net streams, you'll have to do it manually with the asset manager.	 */	public class FLV extends EventDispatcher	{				/**		 * Whether or not to trace out status events		 * from the net stream.		 */		public var traceStatuses:Boolean;		
		/**		 * @private		 * The net stream object.		 */		protected var stream:NetStream;				/**		 * @private		 * The net connection for the flv.		 */		protected var nc:NetConnection;				/**		 * @private		 * The video object.		 */		protected var display:Video;				/**		 * @private		 * The url currently playing.		 */
		protected var url:String;				/**		 * @private		 * Pased flag.		 */		protected var paused:Boolean;				/**		 * @private		 * Started flag.		 */		protected var started:Boolean;				/**		 * @private		 * The duration of the current flv.		 */		protected var duration:Number;				/**		 * @private		 * Meta data.		 */		protected var metadata:Object;				/**		 * @private		 * The last seekable time.		 */		protected var lastSeekableTime:Number;				/**		 * @private		 * The math utils singleton.		 */		protected var mu:MathUtils;		/**		 * The amount of pixels to use when calculating		 * how many pixels have played and how many		 * pixels for buffer are full.		 */		public var pixelsToFill:int;		/**		 * A timer that polls the net stream for status.		 */		private var checkTimer:Timer;				/**		 * The asset manager instance.		 */		private var am:AssetManager;				/**		 * Flag for buffering.		 */		private var buffering:Boolean;				/**		 * Flag for the buffer full event - which doesn't		 * always dispatch when the buffer is indeed full.		 */		private var dispatchedBufferFull:Boolean;				/**		 * A count for the dispatchedBufferFull flag - which		 * determines when an event is forcefully dispatched.		 */		private var checkBufferCount:Number;		/**		 * Constructor for FLV instances.		 * 		 * @param width The width of the video object.		 * @param height The height of the video object.		 * @param smoothing Whether or not smoothing is applied.		 * @param updateInterval The millisecond interval to poll for progress and buffer.		 * @param pixelsToFill The amount of pixels to fill for a progress status bar.		 */		public function FLV(pixelsToFill:int=100,updateIntervalMS:int=400)		{			super();			this.pixelsToFill = pixelsToFill;			am = AssetManager.gi();			mu = MathUtils.gi();			duration = 1000000000;			checkTimer = new Timer(400);			checkTimer.addEventListener(TimerEvent.TIMER,ontick);			display=new Video();			checkBufferCount = 0;		}		/**		 * Loads the video, and optionally shows the first frame.		 * 		 * @param url The url of the FLV to load.		 * @param width The width of the video.		 * @param height The height of the video.		 * @param buffer Seconds of buffer to maintain.		 * @param autoPlay Whether or not to auto play the video.		 * @param showFirstFrame Whether or not to show the first frame of the flv if auto play is false.		 */		public function load(url:String,width:int=320,height:int=240,buffer:uint=4,autoPlay:Boolean=false,showFirstFrame:Boolean=true):void		{			if(this.url&&this.url==url) return;			this.url=url;			started=false;			paused=false;			if(!nc)			{				nc = new NetConnection();				nc.connect(null);			}			if(!display) display=new Video(width,height);			else			{				display.width=width;				display.height=height;			}			display.smoothing=true;			if(stream)			{				stream.pause();				stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);			}			if(am.isAvailable(url)) stream=am.getNetStream(url);			else			{				stream = new NetStream(nc);				am.addAsset(url,stream);			}			stream.addEventListener(NetStatusEvent.NET_STATUS,onNSStatus,false,0,true);			stream.client = this;			stream.bufferTime = buffer;			display.clear();			display.attachNetStream(stream);			buffering = true;			if(autoPlay) play();			if(!autoPlay) pause();			else if(!autoPlay && showFirstFrame) setTimeout(seek,500,0);			checkTimer.start();		}				/**		 * Start the timer, it it's not already running.		 */		private function startTimer():void		{			if(!checkTimer.running) checkTimer.start();		}				/**		 * Stop the timer.		 */		private function stopTimer():void		{			checkTimer.stop();		}				/**		 * Set the video display width.		 */		public function set width(w:int):void		{			display.width = w;		}				/**		 * Set the video display height.		 */		public function set height(h:int):void		{			display.height = h;		}				/**		 * Set the smoothing property on the video.		 */		public function set smoothing(v:Boolean):void		{			display.smoothing = v;		}				/**		 * Play the flv.		 */		public function play():void		{			startTimer();			display.clear();			if(started||stream.bytesLoaded>0)			{				stream.seek(0);				stream.resume();			}			else stream.play(url);			started = true;			paused = false;		}				/**		 * Stop the flv.		 */		public function stop():void		{			stream.pause();			started = false;			paused = false;		}				/**		 * Pause the flv.		 */		public function pause():void		{			if(!paused && started)			{				paused = true;				stream.pause();			}		}		/**		 * Resume the flv playback.		 */		public function resume():void		{			if(paused && started)			{				startTimer();				paused = false;				stream.resume();			}		}		/**		 * Pauses or resumes the flv.		 */		public function pauseResume():void		{			if(paused) resume();			else pause();		}				/**		 * Fast-forward playback.		 * 		 * @param step seconds to step forward.		 */		public function forward(step:Number=2):void		{			seek(getTime()+step);		}		/**		 * Rewind playback.		 * 		 * @param step seconds to step backwards.		 */		public function rewind(step:Number=2):void		{			seek(getTime()-step);		}				/**		 * Check if the FLV is paused.		 */		public function isPaused():Boolean		{			return paused;		}		/**		 * Check if the FLV is playing.		 */		public function isPlaying():Boolean 		{			return started;		}		/**		 * Check if the FLV is stopped.		 */		public function isStopped():Boolean		{			return !started;		}		/**		 * @private		 * The current time of the flv.		 */		public function getTime():Number		{			return stream.time;		}				/**		 * Get the current time.		 */		public function get currentTime():Number		{			return stream.time;		}				/**		 * Get the total time.		 */		public function get totalTime():Number		{			return duration;		}				/**		 * Seek to a playback time - note that unless you're using		 * a flash media server, it will only seek to the nearest		 * key frame (i-frame) (see video docs in flash help for more info).		 * 		 * @param time The time in seconds to seek to.		 */		public function seek(time:Number):void		{			stream.seek(resolveTime(time));		}		/**		 * Seek to a playback percent.		 * 		 * @param percent of playback to seek to.		 */		public function seekToPercent(percent:Number):void		{			seek(duration*percent/100);		}				/**		 * Seek to a width based off of the pixels to fill		 * (pixelsToFill) property. For example, if the pixels		 * to fill was 300, you could seek anywhere between		 * 0-300.		 * 		 * @param pixel The width to seek to.		 */		public function seekToPixel(pixel:int):void		{			if(pixelsToFill < 1)			{				trace("WARNING: pixelsToFill is less than 1, no seeking will occur.");				return;			}			seek(resolveTime(mu.spread(pixel,pixelsToFill,duration)));		}				/**		 * The percent of the video that has played.		 */		public function get percentPlayed():Number		{			return getTime()*100/duration;		}						/**		 * The percent of the video that has loaded.		 */		public function get percentLoaded():Number		{			var b:Number = Math.round(stream.bytesLoaded/stream.bytesTotal*100);			return (isNaN(b))?0:b;		}		/**		 * The percent of the total buffer that is full.		 */		public function get percentBuffered():Number		{			var total:Number = Math.min(duration,stream.bufferTime);			var b:Number = Math.min(Math.round(stream.bufferLength/total*100),100);			return (isNaN(b))?0:b;		}				/**		 * @private		 * The amount of pixels that are full. For example, you might 		 * set the pixels to fill to 300, and if only half of the buffer		 * is full, you'd get back the number 150.		 */		public function get pixelsBuffered():Number		{			return mu.spread(stream.bufferLength,stream.bufferTime,pixelsToFill);		}				/**		 * The amount of pixels that are full. For example, you might		 * set the pixels to fill to 300, and if the movie is 50% played		 * through, you'd get back the number 150. Which correlates to		 * 50% of 300.		 */		public function get pixelsPlayed():Number		{			var i:Number = mu.spread(getTime(),duration,pixelsToFill); 			return i;		}						/**		 * Set the video volume.		 * 		 * @param volume The volume level - 0-1.		 */		public function set volume(volume:Number):void		{			var st:SoundTransform = stream.soundTransform;			st.volume = volume;			stream.soundTransform = st;		}				/**		 * The volume of the video player.		 */		public function get volume():Number		{			var st:SoundTransform = stream.soundTransform;			return st.volume;		}				/**		 * The sound transform of the stream.		 */		public function get soundTransform():SoundTransform		{			if(stream) return stream.soundTransform;			return null;		}				/**		 * Sets the sound transform on the stream.		 */		public function set soundTransform(st:SoundTransform):void		{			stream.soundTransform = st;		}		/**		 * The internal video object used to display the		 * flv.		 */		public function get video():Video		{			return display;		}		/**		 * The currently playing net stream.		 */		public function get netStream():NetStream		{			return stream;		}		/**		 * @private		 * 		 * Formats time so that it fits inside the available seek scope.		 * 		 * @param time The time from the net stream.		 */		protected function resolveTime(time:Number):Number		{			var maxTime:Number = (!isNaN(lastSeekableTime))?lastSeekableTime:duration;			return Math.max(Math.min(time,maxTime),0);		}		/**		 * Stops playback, closes the net stream, and		 * removes the net stream from the asset manager.		 */		public function dispose():void		{			stop();			stopTimer();			if(checkTimer) checkTimer.removeEventListener(TimerEvent.TIMER,ontick);			if(stream)			{				if(am.isAvailable(url)) am.removeAsset(url);				stream.removeEventListener(NetStatusEvent.NET_STATUS,onNSStatus);				stream.close();			}			if(display) display.clear();			if(nc) nc.close();			display = null;			stream = null;			nc = null;		}				/**		 * @private		 * 		 * Progress frame loop to keep client progress up to date.		 */		protected function ontick(te:TimerEvent):void		{			dispatchEvent(new FLVEvent(FLVEvent.PROGRESS,url,percentLoaded,percentPlayed,percentBuffered,pixelsBuffered,pixelsPlayed,null,metadata,stream.bytesLoaded,stream.bytesTotal));			if(percentBuffered >= 100)			{				checkBufferCount++;				if(checkBufferCount > 4 && !dispatchedBufferFull)				{					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					dispatchedBufferFull = true;					checkBufferCount = 0;				}			}		}				/**		 * @private		 * NetStatus handler.		 */		protected function onNSStatus(stats:NetStatusEvent):void		{			if(traceStatuses) trace("netstat: ",stats.info.code);			switch(stats.info.code)			{				case "NetStream.Buffer.Empty":					buffering = true;					dispatchedBufferFull = false;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_EMPTY));					break;				case "NetStream.Buffer.Full":					buffering = false;					dispatchedBufferFull = true;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FULL));					break;				case "NetStream.Buffer.Flush":					buffering = false;					dispatchEvent(new FLVEvent(FLVEvent.BUFFER_FLUSH));					break;				case "NetStream.Play.Start":					dispatchEvent(new FLVEvent(FLVEvent.START));					break;				case "NetStream.Play.Stop":					dispatchEvent(new FLVEvent(FLVEvent.STOP));					break;				case "NetStream.Play.StreamNotFound":					stopTimer();					dispatchEvent(new FLVEvent(FLVEvent.STREAM_NOT_FOUND,url));					break;				case "NetStream.Seek.InvalidTime":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_INVALID_TIME));					break;				case "NetStream.Seek.Notify":					dispatchEvent(new FLVEvent(FLVEvent.SEEK_NOTIFY));					break;			}		}		/**		 * @private		 * CuePoint handler.		 */		public function onCuePoint(infoObject:Object):void		{			if(buffering) return;			dispatchEvent(new FLVEvent(FLVEvent.METADATA,url,percentLoaded,percentPlayed,percentBuffered,pixelsBuffered,pixelsPlayed,infoObject,null));		}		/**		 * @private		 * Meta data handler.		 */		public function onMetaData(metadata:Object):void		{			this.metadata = metadata;			duration = metadata.duration;			lastSeekableTime = metadata.lastkeyframetimestamp;			dispatchEvent(new FLVEvent(FLVEvent.METADATA,url,percentLoaded,percentPlayed,percentBuffered,pixelsBuffered,pixelsPlayed,null,metadata));		}	}}		