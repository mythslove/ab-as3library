package uk.co.soulwire.ui{	import caurina.transitions.Tweener;	import flash.events.Event;	import flash.geom.Rectangle;	import gs.TweenLite;	import gs.easing.Expo;	import org.casalib.display.CasaSprite;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.utils.Dictionary;	import uk.co.soulwire.ui.ShuffleGridItem;	/**	 * @author justinwindle	 */	public class ShuffleGrid extends CasaSprite 	{		public var tweenTime : Number = 0.2;		public var itemAlphaOff : Number = 0.8;				public function get numCells() : int		{			return _rows * _cols;		}				private var _rows : int;		private var _cols : int;		private var _padd : int;		private var _rowSize : int;		private var _colSize : int;		private var _index : Array;		private var _items : Array;		private var _numItems : int;		private var _dictionary : Dictionary;		private var _currentItem : ShuffleGridItem;		private var mouse_position_on_press:Point;		private var item_position_on_press:Point;		private var dragging_item:Boolean;		private var max_width:Number;		private var max_height:Number;				public function ShuffleGrid(rows : int, cols : int, rowSize : int, colSize : int, padding : Number = 0)		{			_rows 		= rows;			_cols 		= cols;			_padd 		= padding;			_rowSize 	= rowSize;			_colSize 	= colSize;			_numItems 	= 0;						initIndex();						this.addEventListener(Event.ADDED_TO_STAGE, addedHandler, false, 0, true);		}				private function addedHandler(e:Event):void 		{			removeEventListener(Event.ADDED_TO_STAGE, addedHandler);						max_width  = _cols * _colSize;			max_height = _rows * _rowSize;		}				public function addItem(item : ShuffleGridItem) : ShuffleGridItem		{			var col:int = _numItems % _cols;			var row:int = Math.floor(_numItems / _cols);						var itemVO:ShuffleGridItemVO 	= new ShuffleGridItemVO();			var position:Point 				= getPosition(row, col);						itemVO.row 	= row;			itemVO.col 	= col;			itemVO.item = item;						item.x 		= position.x;			item.y 		= position.y;						item.mouseEnabled 	= true;			item.buttonMode 	= true;						item.addEventListener(MouseEvent.MOUSE_DOWN, onItemPress, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_UP, onItemRelease, false, 0, true);						addChild(item);						_items.push(item);			_index[row][col] 	= itemVO;			_dictionary[item] 	= itemVO;			_numItems++;						return item;		}				public function getItemAt(index : int) : ShuffleGridItem		{			return _items[index];		}				//public function getItemAtPosition(row : int, col : int) : ShuffleGridItemVO		//{			//var item:ShuffleGridItemVO;			//			//if(_index[row] != null && _index[row].length > col)			//{				//item = _index[row][col];			//}			//else			//{				//item = null;			//}			//			//return item;		//}		//				public function getItemAtPosition(row : int, col : int) : ShuffleGridItemVO		{			var item:ShuffleGridItemVO;						if(_index[row] != null && _index[row].length > col)			{				item = _index[row][col];			}			else			{				item = null;			}						return item;		}								//public function getItemAtPosition(row : int, col : int) : ShuffleGridItem		//{			//return _index[row][col];		//}				private function initIndex() : void		{			_dictionary = new Dictionary();			_index 		= new Array(_rows);			_items 		= [];						for (var i : int = 0;i < _rows; i++)			{				_index[i] = new Array(_cols);			}		}				private function snapToGrid(item : ShuffleGridItemVO) : void		{			var pos : Point = getPosition(item.row, item.col);			TweenLite.to(item.item, tweenTime, {x:pos.x, y:pos.y, ease:Expo.easeInOut});		}				private function getPosition(row : int, col : int) : Point		{			return new Point(col * (_colSize + _padd), row * (_rowSize + _padd));			return new Point(col * (_rowSize + _padd), row * (_colSize + _padd));		}				/// additional methods for drop				private function snapToGridOnDrop(item : ShuffleGridItemVO) : void		{			var pos : Point = getLastPositionMaybe(item.row, item.col);			//var pos : Point = getPosition(item.row, item.col);			TweenLite.to(item.item, tweenTime, {x:pos.x, y:pos.y, ease:Expo.easeInOut});		}				private function getLastPositionMaybe(row:int, col:int) : Point		{			trace("getLastPositionMaybe ::: col : " + col);			trace("getLastPositionMaybe ::: row : " + row);			/// if we are in the last row, use other technique otherwise use the same						var _lastRow:int = Math.floor(_numItems / _cols);			var _lastCol:int = Math.floor(_numItems / _rows) - 1;						var point_to_return:Point;						trace("_lastCol : " + _lastCol);			trace("_lastRow : " + _lastRow);						if (row == _lastRow && _lastCol != 0)			{				trace("yes it is");								point_to_return = new Point(_lastCol * (_colSize + _padd), row * (_rowSize + _padd));			}			else			{				point_to_return = new Point(col * (_colSize + _padd), row * (_rowSize + _padd));			}						return point_to_return;			//var _lastRow:int = Math.floor(_numItems / _cols);		}				private function getCell(x : Number, y : Number) : Point		{			var cell : Point = new Point();						cell.x = Math.max(0, Math.min(_cols - 1, Math.round(x / (_colSize + _padd))));			cell.y = Math.max(0, Math.min(_rows - 1, Math.round(y / (_rowSize + _padd))));						return cell;		}				private function onItemPress(event : MouseEvent) : void		{			dragging_item = true						_currentItem = event.currentTarget as ShuffleGridItem;			//_currentItem.addEventListener(MouseEvent.MOUSE_OUT, onItemRelease, false, 0, true);			_currentItem.alpha = itemAlphaOff;			_currentItem.startDrag(false, new Rectangle(0, 0, max_width, max_height));						if (mouse_position_on_press != null) { mouse_position_on_press == null; }						mouse_position_on_press = new Point(stage.mouseX, stage.mouseY);			item_position_on_press  = new Point(_currentItem.x, _currentItem.y);						//stage.addEventListener(Event.ENTER_FRAME, 		onItemDrag, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_MOVE, 	onItemMove, false, 0, true);			addChild(_currentItem);		}				private function onItemDrag(e:Event):void 		{			//if (stage.mouseY != mouse_position_on_press.x || stage.mouseY != mouse_position_on_press.y)			//{				//var actual_mouse_point:Point = new Point(stage.mouseX, stage.mouseY);				//				//var new_x_position:Number;				//var new_y_position:Number;				//				//new_x_position = item_position_on_press.x + (actual_mouse_point.x - mouse_position_on_press.x);				//new_y_position = item_position_on_press.y + (actual_mouse_point.y - mouse_position_on_press.y);				//				//var min_x_position:Number = 0 - (_currentItem.width   / 4);				//var min_y_position:Number = 0 - (_currentItem.height / 4);				//var max_x_position:Number = max_width - ((_currentItem.width / 4) * 3);				//var max_y_position:Number = max_height - ((_currentItem.height / 4) * 3);				//				//if (new_x_position < min_x_position)  { new_x_position = min_x_position; }				//if (new_y_position < min_y_position)  { new_y_position = min_y_position; }				//if (new_x_position > max_x_position)  { new_x_position = max_x_position; }				//if (new_y_position > max_y_position)  { new_y_position = max_y_position; }				//				//_currentItem.x = new_x_position;				//_currentItem.y = new_y_position;			//}		}				private function onItemMove(event : MouseEvent) : void		{			shuffleItems();		}				private function onItemRelease(event : MouseEvent) : void		{			if (dragging_item == true) 			{				dragging_item = false;								//_currentItem.removeEventListener(MouseEvent.MOUSE_OUT, onItemRelease);				_currentItem.alpha = 1.0;				_currentItem.stopDrag();								//stage.removeEventListener(Event.ENTER_FRAME, 	 onItemDrag);				stage.removeEventListener(MouseEvent.MOUSE_MOVE, onItemMove);				//shuffleItems();				//snapToGridOnDrop(_dictionary[_currentItem]);				snapToGrid(_dictionary[_currentItem]);			}		}				public function updateIndexArray(numToAdd:int, maxCols:int):void		{			var tempNumItems:uint = numItems + numToAdd;			var i:int;			var j:int;			var cols:int;			var dif:int;						var rows:int = Math.ceil(tempNumItems / maxCols);						for (i = 0; i < rows; i++)			{				if(_index.length < rows)				{					_index.push(new Array());				}								// Pour chaque row on détermine le nombre de col. Tous sauf la dernière auront le maxCols				cols = (i < rows-1)?maxCols:tempNumItems - (i * maxCols);								if(_index[i].length < cols)				{					dif = cols - _index[i].length;										//for (j = 0; j  1)?maxCols:cols;										for (j = 0; j  1) ? maxCols : cols;																				//for (var k:int = 0; k < .length; k++) 					//{						//var item: = [k];						//					//}				}		}				private function shuffleItems() : void		{			var itemVO : ShuffleGridItemVO = _dictionary[_currentItem];			var cell : Point = getCell(_currentItem.x, _currentItem.y);			var col : int = cell.x;			var row : int = (getItemAtPosition(cell.y, cell.x) != null)?cell.y: itemVO.row;			if(col == itemVO.col && row == itemVO.row)			{				return;			}			var hMove : int = col - itemVO.col;			var vMove : int = (row == itemVO.row)?0:row - itemVO.row;			var i : int;			var item : ShuffleGridItemVO;			var move : Array = [];			if(hMove = itemVO.col + hMove; i--)				{					if(_index[itemVO.row][i])					{						item = _index[itemVO.row][i];						item.col++;						_index[item.row][item.col] = item;						move.push(item);					}				}			}			else			{				for (i = itemVO.col + 1;i <= itemVO.col + hMove; i++)				{					if(_index[itemVO.row][i])					{						item = _index[itemVO.row][i];						item.col--;						_index[item.row][item.col] = item;						move.push(item);					}				}			}			if(vMove = itemVO.row + vMove; i--)				{					if(_index[i][itemVO.col + hMove])					{						item = _index[i][itemVO.col + hMove];						item.row++;						if(item.col >= _index[item.row].length)						{							item.col = _index[item.row].length - 1;						}						_index[item.row][item.col] = item;						move.push(item);					}				}			}			else			{				for (i = itemVO.row + 1;i <= itemVO.row + vMove; i++)				{					if(_index[i][itemVO.col + hMove])					{						item = _index[i][itemVO.col + hMove];						item.row--;						_index[item.row][item.col] = item;						move.push(item);					}				}			}			for (i = 0;i  col)			{				itemVO.col = col;			}						_index[row][itemVO.col] = itemVO;		}			}}//var hMove : int = col - itemVO.col;//var vMove : int = row - itemVO.row;//getpositionimport uk.co.soulwire.ui.ShuffleGridItem;internal class ShuffleGridItemVO{	public var row : int;	public var col : int;	public var item : ShuffleGridItem;}/*private function shuffleItems() : void		{			var itemVVO:ShuffleGridItemVO = _dictionary[_currentItem];						var cell:Point = getCell(_currentItem.x, _currentItem.y);						var col:int = (getItemAtPosition(cell.y, cell.x) != null) ? cell.x : itemVVO.col;			var row:int = (getItemAtPosition(cell.y, cell.x) != null) ? cell.y : itemVVO.row;						var colFound:Boolean = false;						if(col == itemVVO.col && row == itemVVO.row)			{				return;			}						var num1:int = col;			var num2:int = itemVVO.col;			var num3:int = num1 - num2;						var num4:int = row;			var num5:int = itemVVO.row;			var num6:int = num4 - num5;						var hhMove : int = (col == itemVVO.col) ? 0 : num3;			var vvMove : int = (row == itemVVO.row) ? 0 : num4;						var i : Number;			var item : ShuffleGridItemVO;			var move : Array = [];						//if(hhMove = itemVVO.col + hhMove; i–-)			if(hhMove == itemVVO.col + hhMove)			{				i--;								if(_index[itemVVO.row][i])				{					item = _index[itemVVO.row][i];					item.col++;										_index[item.row][item.col] = item;					move.push(item);				}			}			else			{				for (i = itemVVO.col + 1;i <= itemVVO.col + hhMove; i++)				{					if(_index[itemVVO.row][i])					{						item = _index[itemVVO.row][i];						item.col = item.col - 1;												_index[item.row][item.col] = item;						move.push(item);					}				}					}						//if(vvMove = itemVVO.row + vvMove; i–-)			if(vvMove == itemVVO.row + vvMove)			{				i--;								if(_index[i][itemVVO.col + hhMove])				{					item = _index[i][itemVVO.col + hhMove];					item.row++;										while (!colFound)					{						if (getItemAtPosition(item.row, item.col)) 						{							colFound = true;						}						else 						{							var num7:int = item.col;							var num8:int = 1;							var num9:int = num7 - num8;														item.col = num9;						}					}										_index[item.row][item.col] = item;					move.push(item);				}			}			else			{				for (i = itemVVO.row + 1;i <= itemVVO.row + vvMove; i++)				{					if(_index[i][itemVVO.col + hhMove])					{						item = _index[i][itemVVO.col + hhMove];						item.row = int(item.row - 1);												_index[item.row][item.col] = item;						move.push(item);					}				}			}						for (i = 0;i < move.length; i++)			{				snapToGrid(move[i]);			}						itemVVO.row = row;			itemVVO.col = col;						_index[row][col] = itemVVO;		}						*/